name: smoketests

on:
  workflow_dispatch:
    inputs:
      platform:
        description: "platform"
        required: true
        type: choice
        options:
          - windows-latest
          - ubuntu-latest
      launcherVersion:
        description: "launcherVersion"
        required: true
        type: choice
        options:
          - Version-1.3
          - Version-2.0
      queuePackage:
        description: "Queue package"
        required: true
        type: choice
        options:
          - fiskaltrust.Middleware.Queue.SQLite
          - fiskaltrust.Middleware.Queue.MySQL
          - fiskaltrust.Middleware.Queue.EF
      queueVersion:
        description: "Queue package version"
        type: string
        default: latest
     
permissions:
  id-token: write
  contents: read

env:
  launcher: "fiskaltrust.service.launcher"
  launcherpath: "./launcher"
 
jobs:
  test-middleware:
    runs-on: ${{ inputs.platform }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4      

      - name: Create cashbox
        shell: pwsh
        run: |
            $description = "Cashbox-$(Get-Date -Format 'yyyy-MM-dd_HH-mm-ss')"
            $url = "https://templates-sandbox.fiskaltrust.cloud/api/v1/configuration?outlet_number=1&description=$description"

            $headers = @{
              accountid   = "${{ secrets.FT_ACCOUNT_ID }}"
              accesstoken = "${{ secrets.FT_ACCESS_TOKEN }}"
              "Content-Type" = "application/json"
            }

            $body = Get-Content ".github/scripts/template.json" -Raw | ConvertFrom-Json
            $body.ftQueues[0].Package = "${{ inputs.queuePackage }}"
            $body.ftQueues[0].Version = "${{ inputs.queueVersion }}"

            if ("${{ inputs.queuePackage }}" -eq 'fiskaltrust.Middleware.Queue.EF') {
             $connectionString = "Data Source=(localdb)\MSSQLLocalDB;Initial Catalog=TestDb;Integrated Security=True;"
             $body.ftQueues[0].Configuration | Add-Member -NotePropertyName "connectionstring" -NotePropertyValue "$connectionString"
            }

            if ("${{ inputs.queuePackage }}" -eq 'fiskaltrust.Middleware.Queue.MySQL') {
             $connectionString = "Server=localhost;Port=3306;Uid=root;Pwd=my-secret-pw;"
             $body.ftQueues[0].Configuration | Add-Member -NotePropertyName "connectionstring" -NotePropertyValue "$connectionString"
            }

            $body = $body | ConvertTo-Json -Depth 10

            $response = Invoke-RestMethod -Uri $url -Headers $headers -Method Post -Body $body

            # Extract values
            $cashboxId  = $response.cashBoxId
            $accessToken = $response.accessToken
            $queueId = $response.configuration.ftQueues[0].Id

            echo "cashboxId=$cashboxId"   >> $env:GITHUB_ENV
            echo "accessToken=$accessToken" >> $env:GITHUB_ENV
            echo "queueId=$queueId"       >> $env:GITHUB_ENV

      - name: Install MySQL and run service
        if: ${{ inputs.queuePackage == 'fiskaltrust.Middleware.Queue.MySQL' }}
        run: |
            choco install mysql --params "'/port:3306'" -y

            # Start MySQL service if not already running
            $service = Get-Service -Name mysql -ErrorAction SilentlyContinue
            if ($service.Status -ne 'Running') {
              Start-Service mysql
            }

            # Wait for MySQL to be ready
            Write-Host "Waiting for MySQL to be ready..."
            Start-Sleep -Seconds 10

            # Set a known root password
            $mysqladmin = 'C:\tools\mysql\current\bin\mysqladmin.exe'
            & $mysqladmin -u root password "my-secret-pw"

            # Verify connection
            $mysql = 'C:\tools\mysql\current\bin\mysql.exe'
            & $mysql -u root -pmy-secret-pw -e "SELECT VERSION();"

            Write-Host "✅ MySQL root password successfully set and verified."

      - name: Start LocalDB
        if: ${{ inputs.queuePackage == 'fiskaltrust.Middleware.Queue.EF' }}
        shell: pwsh
        run: |
          sqllocaldb create MSSQLLocalDB -s
          sqlcmd -S "(localdb)\MSSQLLocalDB" -Q "SELECT @@VERSION"    

      - name: Download launcher package
        shell: pwsh
        run: |
          $cashboxId = "${{ env.cashboxId }}"
          $accessToken = "${{ env.accessToken }}"
          $platform = ("${{ inputs.platform }}" -eq "ubuntu-latest") ? "linux" : "windows"
          $offline = "false"
          $launcher = "${{ env.launcher }}"
          $version = "latest"

          $pair = "${cashboxId}:${accessToken}"
          $encoded = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($pair))
          $headers = @{ Authorization = "Basic $encoded" }

          $url = "https://packages-sandbox.fiskaltrust.at/$cashboxId.download?launcher=$launcher&version=$version&offline=$offline&platform=$platform"
          $output = "$launcher.$cashboxId.zip"
          Invoke-RestMethod -Uri $url -Headers $headers -OutFile $output

      - name: Extract launcher package
        shell: pwsh
        run: |
         $cashboxId = "${{ env.cashboxId }}"
         $launcher =  "${{ env.launcher }}"
         $zipPath = "$launcher.$cashboxId.zip"
         $extractPath = "${{ env.launcherpath }}"
         
         if (Test-Path $extractPath) {
           Remove-Item -Path $extractPath -Recurse -Force
         }
         Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force

      # - name: Install Mono if platform is Ubuntu
      #   if: ${{ inputs.platform == 'ubuntu-latest' }}
      #   shell: pwsh
      #   run: |
      #     Write-Host "Installing Mono on Linux..."
      #     sudo apt-get update -y
      #     sudo apt-get install -y mono-complete

      # - name: Run launcher on windows
      #   if: ${{ inputs.platform == 'windows-latest' }}
      #   shell: pwsh
      #   run: |
      #     $scriptPath = (Resolve-Path '${{ env.launcherpath }}/test.cmd').Path
      #     Write-Host "Starting test.cmd..."
      #     $process = Start-Process -FilePath "cmd.exe" -ArgumentList @('/c', ('"{0}"' -f $scriptPath)) -PassThru -RedirectStandardOutput test-output.log -RedirectStandardError test-output-error.log
      #     echo "processId=$process.Id"   >> $env:GITHUB_ENV

      #     # Wait a few seconds to let test.cmd start listening
      #     Write-Host "Waiting for launcher to become ready (max 60s)"
      #     Start-Sleep -Seconds 120

      #     $maxAttempts = 10
      #     for ($i = 1; $i -le $maxAttempts; $i++) {
      #       if ((Test-NetConnection -ComputerName "localhost" -Port 1500 -WarningAction SilentlyContinue).TcpTestSucceeded) {
      #           Write-Host "Launcher is ready!"
      #           echo "launcherhealthcheck=ready" >> $env:GITHUB_ENV
      #           break
      #       }

      #       Write-Host "Launcher not ready yet, waiting 5s... (Attempt $i/$maxAttempts)"
      #       Start-Sleep -Seconds 5
      #     }

      # - name: Run launcher on Linux
      #   if: ${{ inputs.platform == 'ubuntu-latest' }}
      #   shell: bash
      #   run: |
      #       SCRIPT_PATH="${{ env.launcherpath }}/test.sh"
      #       echo "Starting test.sh..."
      #       bash "$SCRIPT_PATH" > test-output.log 2> test-output-error.log &
      #       PROCESS_ID=$!
      #       echo "processId=$PROCESS_ID" >> $GITHUB_ENV

      #       echo "Waiting for launcher to become ready (max 60s)"
      #       for i in {1..12}; do
      #         if nc -z localhost 1500; then
      #           echo "Launcher is ready!"
      #           echo "launcherhealthcheck=ready" >> $GITHUB_ENV
      #           break
      #         fi
      #         echo "Launcher not ready yet, waiting 5s... (Attempt $i/12)"
      #         sleep 5
      #       done
      - name: Run Mono launcher in Docker, send requests
        if: ${{ runner.os != 'Windows' }}
        shell: bash
        run: |
            # Paths
            LAUNCHER_PATH="$PWD/launcher"
            REQUESTS_PATH="$PWD/.github/scripts/requests"
            QUEUE_ID="${{ env.queueId }}"
            CASHBOX_ID="${{ env.cashboxId }}"

            # Use official Mono image
            IMAGE="mono:latest"
            # Run launcher in detached container
            CONTAINER_ID=$(docker run -d -v "$LAUNCHER_PATH:/launcher" -w /launcher $IMAGE \
            bash -c "chmod +x ./test.sh && exec ./test.sh")

            echo "Launcher container ID: $CONTAINER_ID"

            # Wait for launcher to become ready (TCP 1500)
            MAX_ATTEMPTS=10
            for i in $(seq 1 $MAX_ATTEMPTS); do
              if docker exec $CONTAINER_ID bash -c "curl -s http://localhost:1500/ >/dev/null 2>&1"; then
                echo "Launcher is ready!"
                break
              fi
              echo "Launcher not ready yet, waiting 5s... (Attempt $i/$MAX_ATTEMPTS)"
              sleep 10
            done
             docker logs --tail 20 $CONTAINER_ID
            # Send requests
                     

            BASE_URL="http://localhost:1500/$QUEUE_ID"
            REQUESTS_PATH=".github/scripts/requests"

            requests=(
              "Echo|$BASE_URL/json/v1/Echo|$REQUESTS_PATH/Echo.json"
              "ZeroReceipt|$BASE_URL/json/v1/sign|$REQUESTS_PATH/Zeroreceipt.json"
              "Initial-operation-receipt|$BASE_URL/json/v1/sign|$REQUESTS_PATH/Initial-operation-receipt.json"
              "Pos-receipt|$BASE_URL/json/v1/sign|$REQUESTS_PATH/Pos-receipt.json"
              "Daily-closing-receipt|$BASE_URL/json/v1/sign|$REQUESTS_PATH/Daily-closing-receipt.json"
              "DSFinVK-Export|$BASE_URL/json/v0/Journal?type=4919338167972134914|"
              "Tar-Export-from-middleware|$BASE_URL/json/v0/Journal?type=4919338167972134915|"
              "Action-Journal-Export|$BASE_URL/json/v0/Journal?type=1|"
              "Receipt-Journal-Export|$BASE_URL/json/v0/Journal?type=2|"
              "QueueItem-Export|$BASE_URL/json/v0/Journal?type=3|"
            )

            for req in "${requests[@]}"; do
              IFS="|" read -r NAME URL FILE <<< "$req"
              echo -e "\n--- Sending $NAME request ---"

              if [[ -n "$FILE" && -f "$FILE" ]]; then
                BODY=$(<"$FILE")
                BODY="${BODY//\{\{cashbox_id\}\}/$CASHBOX_ID}"
                BODY="${BODY//\{\{current_moment\}\}/$(date -Iseconds)}"

                echo "POST $URL"
                echo "Body:"
                echo "$BODY" | jq . || echo "$BODY"  # pretty print if jq available

                RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST "$URL" \
                  -H "Content-Type: application/json" -d "$BODY" || true)
              else
                echo "POST $URL (no body)"
                RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST "$URL" || true)
              fi

              HTTP_BODY=$(echo "$RESPONSE" | sed -e 's/HTTP_STATUS\:.*//g')
              HTTP_STATUS=$(echo "$RESPONSE" | tr -d '\n' | sed -e 's/.*HTTP_STATUS://')

              echo "Response Code: $HTTP_STATUS"
              echo "Response Body: $HTTP_BODY"

              if [[ "$HTTP_STATUS" -lt 200 || "$HTTP_STATUS" -ge 300 ]]; then
                echo "❌ $NAME failed with HTTP $HTTP_STATUS"
              else
                echo "✅ $NAME succeeded"
              fi
            done


            echo "Requests sent. Launcher container is still running if needed."
            echo "Container logs (partial):"
            docker logs --tail 20 $CONTAINER_ID
 
      - name:  Run launcher,send requests, and stop
        if: ${{ runner.os == 'Windows' }}
        shell: pwsh
        run: |
          #....Run launcher....
          Write-Host "Starting launcher..."
          $launcherPath = Resolve-Path "${{ env.launcherpath }}"
          if ($isWindows) {
             $scriptPath = (Resolve-Path '${{ env.launcherpath }}/test.cmd').Path
             $process = Start-Process -FilePath "cmd.exe" -ArgumentList @('/c', ('"{0}"' -f $scriptPath)) -PassThru -RedirectStandardOutput test-output.log -RedirectStandardError test-output-error.log
             $processId = $process.Id
           } else {
              echo "Starting launcher on Linux..."
              $scriptPath = (Resolve-Path '${{ env.launcherpath }}/test.sh').Path
              bash -c "chmod +x '$scriptPath'"
              # Build the bash command safely
              $processId = bash -c "cd '$launcherPath' && script -q -c './test.sh' /dev/null > test-output.log 2> test-output-error.log & echo \$!"

              
              $logOut = Join-Path $launcherPath "test-output.log"
              $logErr = Join-Path $launcherPath "test-output-error.log"
              if (Test-Path $logOut) {
                Write-Host "=== test-output.log ==="
                Get-Content $logOut
              }
              if (Test-Path $logErr) {
                Write-Host "=== test-output-error.log ==="
                Get-Content $logErr
              }
               #$processId = bash -c "& '$scriptPath' > test-output.log 2> test-output-error.log & echo \$!"
              echo "pid=$processId" 
              $processId = $processId
              #$process = Start-Process -FilePath "/bin/bash" -ArgumentList @($scriptPath) -PassThru -RedirectStandardOutput test-output.log -RedirectStandardError test-output-error.log
          }

          # Wait a few seconds to let test.cmd start listening
          Write-Host "Waiting for launcher to become ready (max 60s)"
          Start-Sleep -Seconds 60

          $maxAttempts = 10
          for ($i = 1; $i -le $maxAttempts; $i++) {
            if ($isWindows) {
                $tcpReady = (Test-NetConnection -ComputerName "localhost" -Port 1500 -WarningAction SilentlyContinue).TcpTestSucceeded
            } else {
                $tcpReady = (bash -c "nc -z localhost 1500") -eq 0
            }

            if ($tcpReady) {
                Write-Host "Launcher is ready!"
                break
            }

            Write-Host "Launcher not ready yet, waiting 5s... (Attempt $i/$maxAttempts)"
            Start-Sleep -Seconds 5
          } 

          #....Send requests....
          if ($tcpReady) {
           $baseUrl = "http://localhost:1500/${{ env.queueId }}"
           $baseFile = ".github/scripts/requests"
           $requests = @(
                @{ Name = "Echo";                      Url = "$baseUrl/json/v1/Echo"; File = "$baseFile/Echo.json" }
                @{ Name = "ZeroReceipt";               Url = "$baseUrl/json/v1/sign"; File = "$baseFile/Zeroreceipt.json" }
                @{ Name = "Initial-operation-receipt"; Url = "$baseUrl/json/v1/sign"; File = "$baseFile/Initial-operation-receipt.json" }
                @{ Name = "Pos-receipt";               Url = "$baseUrl/json/v1/sign"; File = "$baseFile/Pos-receipt.json" }
                @{ Name = "Daily-closing-receipt";     Url = "$baseUrl/json/v1/sign"; File = "$baseFile/Daily-closing-receipt.json" }
                @{ Name = "DSFinVK-Export";            Url = "$baseUrl/json/v0/Journal?type=4919338167972134914"; File = "" }
                @{ Name = "Tar-Export-from-middleware";Url = "$baseUrl/json/v0/Journal?type=4919338167972134915"; File = "" }
                @{ Name = "Action-Journal-Export";     Url = "$baseUrl/json/v0/Journal?type=1"; File = "" }
                @{ Name = "Receipt-Journal-Export";    Url = "$baseUrl/json/v0/Journal?type=2"; File = "" }
                @{ Name = "QueueItem-Export";          Url = "$baseUrl/json/v0/Journal?type=3"; File = "" }
            )
            
            foreach ($req in $requests) {
                Write-Host "`n--- Sending $($req.Name) request ---"
            
                if ($req.File -and (Test-Path $req.File) -and ((Get-Item $req.File).Length -gt 0)) {       
                 $bodyTemplate = Get-Content $req.File -Raw 
                 $body = $bodyTemplate -replace "{{cashbox_id}}", "${{ env.cashboxId }}" -replace "{{current_moment}}", (Get-Date).ToString("o")
                }

                try {

                  if ($null -ne $body) {
                        $response = Invoke-RestMethod -Uri $req.Url -Method Post -Body $body -ContentType "application/json" 
                  } else {
                        $response = Invoke-RestMethod -Uri $req.Url -Method Post 
                  }
                  Write-Host "Response: $($response | ConvertTo-Json)"

                } 
                catch {
                    Write-Error "$($req.Name) request failed: $_"
                }
             }
            }
            else {
              Write-Error "Launcher failed to start within the expected time."
            }

            #....Stop launcher....
            Write-Host "Stopping launcher process..."
            Stop-Process -Id $process.Id -Force -ErrorAction SilentlyContinue      

      - name: Upload test output
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-output-${{ inputs.queuePackage }}
          path: test-output.log
        continue-on-error: true
 
  